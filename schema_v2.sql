-- Extension pour les UUIDs (tentative d'activation)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Nettoyage complet
DROP TABLE IF EXISTS public.notes CASCADE;
DROP TABLE IF EXISTS public.planning CASCADE;
DROP TABLE IF EXISTS public.eleves CASCADE;
DROP TABLE IF EXISTS public.classes CASCADE;
DROP TABLE IF EXISTS public.professeurs CASCADE;
DROP TABLE IF EXISTS public.debug_log CASCADE;

-- 1. Table de LOG ultra-simple (SANS UUID pour éviter les erreurs d'extension)
CREATE TABLE public.debug_log (
    id bigint generated by default as identity PRIMARY KEY,
    mess text,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

-- 2. Table des professeurs
CREATE TABLE public.professeurs (
    id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email text UNIQUE NOT NULL,
    nom text,
    prenom text,
    code_professeur text UNIQUE,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

-- 3. Fonction de création automatique de profil (BLINDÉE)
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  -- Bloc d'insertion principal
  BEGIN
    INSERT INTO public.professeurs (id, email, nom, prenom, code_professeur)
    VALUES (
      new.id,
      new.email,
      COALESCE(new.raw_user_meta_data->>'nom', 'Professeur'),
      COALESCE(new.raw_user_meta_data->>'prenom', ''),
      UPPER(SUBSTRING(MD5(RANDOM()::TEXT), 1, 8))
    )
    ON CONFLICT (id) DO NOTHING;
  EXCEPTION WHEN OTHERS THEN
    -- Si ça échoue, on note dans le log mais on ne bloque JAMAIS la création du compte Auth
    INSERT INTO public.debug_log (mess) VALUES ('Erreur insertion prof: ' || SQLERRM);
  END;
  
  RETURN new;
END;
$$;

-- 4. Déclencheur sur auth.users
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- 5. Table des classes
CREATE TABLE public.classes (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    professeur_id uuid REFERENCES public.professeurs(id) ON DELETE CASCADE NOT NULL,
    nom text NOT NULL,
    niveau text,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

-- 6. Table des élèves
CREATE TABLE public.eleves (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    classe_id uuid REFERENCES public.classes(id) ON DELETE CASCADE NOT NULL,
    nom text NOT NULL,
    prenom text NOT NULL,
    code_connexion text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    UNIQUE(nom, prenom, code_connexion)
);

-- 7. Table des notes
CREATE TABLE public.notes (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    eleve_id uuid REFERENCES public.eleves(id) ON DELETE CASCADE NOT NULL,
    trimestre integer NOT NULL CHECK (trimestre BETWEEN 1 AND 3),
    donnees jsonb DEFAULT '{}'::jsonb NOT NULL,
    derniere_maj timestamp with time zone DEFAULT now() NOT NULL,
    UNIQUE(eleve_id, trimestre)
);

-- 8. Table du planning
CREATE TABLE public.planning (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    eleve_id uuid REFERENCES public.eleves(id) ON DELETE CASCADE NOT NULL,
    indicateurs jsonb DEFAULT '{}'::jsonb NOT NULL,
    derniere_maj timestamp with time zone DEFAULT now() NOT NULL,
    UNIQUE(eleve_id)
);

-- RLS (Sécurité)
ALTER TABLE public.professeurs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.classes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.eleves ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.planning ENABLE ROW LEVEL SECURITY;

-- Politiques de base (Propriétaire gère tout)
CREATE POLICY "Prof gère son profil" ON public.professeurs FOR ALL USING (auth.uid() = id);
CREATE POLICY "Prof gère ses classes" ON public.classes FOR ALL USING (professeur_id = auth.uid());
CREATE POLICY "Prof gère ses élèves" ON public.eleves FOR ALL USING (classe_id IN (SELECT id FROM public.classes WHERE professeur_id = auth.uid()));
CREATE POLICY "Prof gère ses notes" ON public.notes FOR ALL USING (eleve_id IN (SELECT e.id FROM public.eleves e JOIN public.classes c ON e.classe_id = c.id WHERE c.professeur_id = auth.uid()));
CREATE POLICY "Prof gère son planning" ON public.planning FOR ALL USING (eleve_id IN (SELECT e.id FROM public.eleves e JOIN public.classes c ON e.classe_id = c.id WHERE c.professeur_id = auth.uid()));

-- Lecture pour les élèves (Public et Anonyme pour la connexion via code)
CREATE POLICY "Lecture publique élèves" ON public.eleves FOR SELECT USING (true);
CREATE POLICY "Lecture publique notes" ON public.notes FOR SELECT USING (true);
CREATE POLICY "Lecture publique planning" ON public.planning FOR SELECT USING (true);

-- Fonctions RPC pour Excel
CREATE OR REPLACE FUNCTION public.sync_notes_excel(p_nom text, p_prenom text, p_trimestre integer, p_donnees jsonb, p_code_professeur text)
RETURNS uuid AS $$
DECLARE v_eleve_id uuid;
BEGIN
    SELECT e.id INTO v_eleve_id FROM public.eleves e JOIN public.classes c ON e.classe_id = c.id JOIN public.professeurs p ON c.professeur_id = p.id
    WHERE e.nom = p_nom AND e.prenom = p_prenom AND p.code_professeur = p_code_professeur;
    IF v_eleve_id IS NULL THEN RAISE EXCEPTION 'Élève non trouvé'; END IF;
    INSERT INTO public.notes (eleve_id, trimestre, donnees, derniere_maj) VALUES (v_eleve_id, p_trimestre, p_donnees, now())
    ON CONFLICT (eleve_id, trimestre) DO UPDATE SET donnees = EXCLUDED.donnees, derniere_maj = now();
    RETURN v_eleve_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.sync_planning_excel(p_nom text, p_prenom text, p_indicateurs jsonb, p_code_professeur text)
RETURNS uuid AS $$
DECLARE v_eleve_id uuid;
BEGIN
    SELECT e.id INTO v_eleve_id FROM public.eleves e JOIN public.classes c ON e.classe_id = c.id JOIN public.professeurs p ON c.professeur_id = p.id
    WHERE e.nom = p_nom AND e.prenom = p_prenom AND p.code_professeur = p_code_professeur;
    INSERT INTO public.planning (eleve_id, indicateurs, derniere_maj) VALUES (v_eleve_id, p_indicateurs, now())
    ON CONFLICT (eleve_id) DO UPDATE SET indicateurs = EXCLUDED.indicateurs, derniere_maj = now();
    RETURN v_eleve_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.sync_eleves_liste_excel(p_nom text, p_prenom text, p_classe_nom text, p_niveau text, p_code_professeur text)
RETURNS text AS $$
DECLARE v_prof_id uuid; v_classe_id uuid; v_eleve_id uuid; v_code_connexion text;
BEGIN
    SELECT id INTO v_prof_id FROM public.professeurs WHERE code_professeur = p_code_professeur;
    IF v_prof_id IS NULL THEN RAISE EXCEPTION 'Professeur non trouvé'; END IF;
    SELECT id INTO v_classe_id FROM public.classes WHERE nom = p_classe_nom AND professeur_id = v_prof_id;
    IF v_classe_id IS NULL THEN INSERT INTO public.classes (professeur_id, nom, niveau) VALUES (v_prof_id, p_classe_nom, p_niveau) RETURNING id INTO v_classe_id; END IF;
    SELECT id, code_connexion INTO v_eleve_id, v_code_connexion FROM public.eleves WHERE nom = p_nom AND prenom = p_prenom AND classe_id = v_classe_id;
    IF v_eleve_id IS NULL THEN v_code_connexion := UPPER(SUBSTRING(MD5(RANDOM()::TEXT), 1, 6)); INSERT INTO public.eleves (classe_id, nom, prenom, code_connexion) VALUES (v_classe_id, p_nom, p_prenom, v_code_connexion) RETURNING id INTO v_eleve_id; END IF;
    RETURN v_code_connexion;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.login_eleve(p_nom text, p_prenom text, p_code text)
RETURNS TABLE (id uuid, nom text, prenom text, classe_nom text) AS $$
BEGIN
    RETURN QUERY SELECT e.id, e.nom, e.prenom, c.nom as classe_nom FROM public.eleves e JOIN public.classes c ON e.classe_id = c.id
    WHERE LOWER(TRIM(e.nom)) = LOWER(TRIM(p_nom)) AND LOWER(TRIM(e.prenom)) = LOWER(TRIM(p_prenom)) AND e.code_connexion = p_code;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Permissions
GRANT ALL ON TABLE public.debug_log TO postgres, service_role, authenticated;
GRANT ALL ON TABLE public.professeurs TO postgres, service_role, authenticated;
GRANT ALL ON TABLE public.classes TO postgres, service_role, authenticated;
GRANT ALL ON TABLE public.eleves TO postgres, service_role, authenticated;
GRANT SELECT ON TABLE public.eleves TO anon;
GRANT ALL ON TABLE public.notes TO postgres, service_role, authenticated;
GRANT SELECT ON TABLE public.notes TO anon;
GRANT ALL ON TABLE public.planning TO postgres, service_role, authenticated;
GRANT SELECT ON TABLE public.planning TO anon;
